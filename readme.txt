3. 注意点
       关于RequestCondition的自定义，需要说明的主要有三点：
	在DispatcherServlet初始化时，Spring判断当前BeanFactory中是否存在自定义的HandlerMapping对象时，有两种方式：
		①判断当前BeanFacotry中是否有名称为handlerMapping的bean；②直接获取当前BeanFactory中实现了HandlerMapping接口的所有bean，
		这也是默认使用的一种方式。如果按照这两种方式中指定的一种无法获取的HandlerMapping对象，然后才会创建一个默认的RequestMappingHandlerMapping对象来处理请求；
		
	如果使用了自定义的RequestMapping处理请求，那么在Spring的配置文件中尽量不要使用<mvc:annotation-driven/>标签，
		因为Spring在解析该标签时会往BeanFactory中注册一个RequestMappingHandlerMapping的对象，这样就会对我们自定义的HandlerMapping进行干扰，
		因为需要注意request具体是由我们定义的HandlerMapping处理的还是Spring提供的RequestMappingHandlerMapping处理的。如果确实需要使用该标签，
		这里可以为我们自定义的HandlerMapping实现一个PriorityOrdered接口，这样可以保证其会在RequestMappingHandlerMapping之前先判断是否能够处理当前请求；
		
	上述UserController中定义了两个几乎完全的接口，对于Spring而言，其是不允许容器中有两个一模一样的接口的。但这是针对于没有定制RequestCondition的情况而言的
	，Spring在进行两个接口判断（其实就是封装接口的RequestMappingInfo对象的判断）的时候，会将RequestCondition对象的判断也纳入其中，如果对其进行了定制，
	并且两个RequestMappingInfo所持有的RequestCondition对象是不一样的，那么即使其他条件相同，也会认为两个RequestMappingInfo是不一样的，具体的读者可以阅读MappingRegistry.assertUniqueMethodMapping()方法的源码
